#!/bin/sh
# minc-core : Pure shell script mini container core script
#
# Copyright (C) 2014,2015 Masami Hiramatsu <masami.hiramatsu@gmail.com>
# This program is released under the MIT License, see LICENSE.
LIBEXEC=`dirname $0`
MINCCOAT=$LIBEXEC/minc-coat

# Exit if any errors
set -e
test "$MINC_DEBUG" && set -x

# Ensure parameters are set
test -d "$MINC_BASEDIR"
test -d "$MINC_TMPDIR"

bindmount() { # dir
  mount --bind $1 $RD$1
}

grepumount() { # patterns
  cut -f 2 -d " " < /proc/mounts | grep $@ | sort -r | xargs umount 2>/dev/null || echo -n ""
}

# If PID=1, this is in the new world
if [ $$ -eq 1 ]; then
  # At this point, we still have original namespace procfs
  MINC_PID=`cut -f 4 -d" " /proc/self/stat`

  # Make private mount namespace
  mount --make-rprivate /

  # Do not update /etc/mtab since the mount is private
  export LIBMOUNT_MTAB=/proc/mounts

  # Setup overlay rootfs
  $MINCCOAT bind $MINC_TMPDIR $MINC_BASEDIR

  RD=$MINC_TMPDIR/root
  mkdir -p $RD/etc $RD/dev $RD/sys $RD/proc

  if [ "$MINC_UTSNAME" ]; then
    hostname $MINC_UTSNAME
    echo $MINC_UTSNAME > $MINC_TMPDIR/utsname
  elif [ -f $MINC_TMPDIR/utsname ]; then
    hostname `cat $MINC_TMPDIR/utsname`
  fi
  echo $MINC_PID > $MINC_TMPDIR/pid

  # Hide /etc/mtab in this namespace
  if [ ! -L $RD/etc/mtab ]; then
    rm -f $RD/etc/mtab
    ln -s /proc/mounts $RD/etc/mtab
  fi

  # Prepare /dev special files
  if [ "$MINC_USE_DEV" ]; then
    mount -t devtmpfs devtmpfs $RD/dev
  else
    # Use fake devfs
    mount -t tmpfs tmpfs $RD/dev
    # Prepare pts
    mkdir $RD/dev/pts
    mount devpts -t devpts -onoexec,nosuid,gid=5,mode=0620,newinstance,ptmxmode=0666 $RD/dev/pts
    ln -s /dev/pts/ptmx $RD/dev/ptmx
    touch $RD/dev/console; bindmount /dev/console
    touch $RD/dev/null; bindmount /dev/null
    touch $RD/dev/zero; bindmount /dev/zero
    test -d /dev/mqueue && mkdir $RD/dev/mqueue && bindmount /dev/mqueue
    # TODO: Add other devices here
  fi

  # Do not bind procfs, since it shows outside pids
  mount -t proc -o ro,nosuid,nodev,noexec proc /proc
  mount -t proc -o rw,nosuid,nodev,noexec,relatime proc $RD/proc
  bindmount /proc/sys
  bindmount /proc/sysrq-trigger
  bindmount /proc/irq
  bindmount /proc/bus
  bindmount /sys

  if [ "$MINC_RWBIND" ]; then
    for i in $MINC_RWBIND; do
      test -d $i && mkdir -p $i
      test -f $i && touch $i
      bindmount $i
    done
  fi

  if [ "$MINC_OPT_SIMPLE" ]; then
    # Simply umount unused mount points
    grepumount -e "^/sys" -e "^/dev" -e "^/run"
  else
    # To unmount all unused mountpoints, use pivot_root to change root
    cd $RD
    mkdir -p .orig
    pivot_root . .orig
    grepumount -e "^/\.orig/"
    # The original root can not unmount because it referred by overlayfs.
    # So, we pivot to the root again, and chroot to overlay directory.
    cd /.orig/
    pivot_root . mnt/
    RD=mnt/
  fi
  if [ "$MINC_OPT_PTY" ]; then
    # HACK: Open an pty for containers
    cat < $RD/dev/pts/ptmx > $RD/dev/null &
  fi
  test "$MINC_USERSPEC" && OPT="--userspec $MINC_USERSPEC"
  exec $MINC_DEBUG_PREFIX chroot $OPT $RD $@
fi

# Setup CPU and network limitations
IP_NETNS=
test "$MINC_NETNS" && IP_NETNS="ip netns exec $MINC_NETNS "
test "$MINC_CPUMASK" && taskset -ap $MINC_CPUMASK $$ > /dev/null

trap '' INT
cp /proc/$$/stat $MINC_TMPDIR/
trap "rm -f $MINC_TMPDIR/stat" EXIT

export MINC_GRANDPARENT=$$

# Enter new namespace and exec command
$IP_NETNS unshare -iumpf $0 $@
